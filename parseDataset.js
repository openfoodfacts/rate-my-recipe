/**
 * Dataset Parser - Converts dataset.tsv to ingredients_config.json
 * 
 * The ingredients, categories, and quantities are configured in a Google Sheets table
 * that is exported to the dataset.tsv file. This script generates a structured 
 * ingredients_config.json file that the application uses.
 * 
 * File Structure:
 * - Lines 1-5: Header comments and metadata
 * - Line 6 (TITLE_LINE): Column headers
 * - Line 7+: Data rows (categories, ingredients, quantities)
 * 
 * Hierarchy:
 * - Category (columns 0-2)
 *   - Ingredient (columns 3-8)
 *     - Quantity (columns 9-18)
 * 
 * Output: data/ingredients_config.json with three main objects:
 * - categories: { [categoryId]: CategoryData }
 * - ingredients: { [ingredientId]: IngredientData }
 * - quantities: { [quantityId]: QuantityData }
 * 
 * Usage: node parseDataset.js
 */

const fs = require("fs");

/**
 * Parses a string to a number, returning undefined for invalid values.
 * 
 * @param {string|number} n - Value to parse
 * @returns {number|undefined} Parsed number or undefined if invalid
 */
const parseNumber = (n) => {
  if (n === undefined || Number.isNaN(n)) {
    return undefined;
  }
  return parseFloat(n);
};

/**
 * Line number (0-indexed) containing column headers in dataset.tsv
 * @constant {number}
 */
const TITLE_LINE = 5;

/**
 * Splits a TSV line into cells and removes carriage returns.
 * 
 * @param {string} line - TSV line to parse
 * @returns {string[]} Array of cell values
 */
const parseLine = (line) =>
  line.split("\t").map((cell) => cell.replace("\r", ""));

const content = fs.readFileSync("dataset.tsv", "utf8");

const lines = content.split("\n");

/**
 * Uncomment those lines to get the COLUMNS object from the line "TITLE_LINE"
 */
console.log("const COLUMNS = {");
parseLine(lines[TITLE_LINE]).forEach((columnTitle, columnIndex) => {
  console.log(`${columnIndex}: "${columnTitle}",`);
});
console.log("}");

/**
 * Column definitions mapping index to column name.
 * Generated from the TITLE_LINE of dataset.tsv.
 * 
 * Structure:
 * - Columns 0-2: Category data
 * - Columns 3-8: Ingredient data
 * - Columns 9-18: Quantity data
 * 
 * @constant {Object.<number, string>}
 */
// Generated by the script before
const COLUMNS = {
  0: "category_name",
  1: "category_id",
  2: "category_description",
  3: "ingredient_name",
  4: "ingredient_id",
  5: "ingredient_description",
  6: "ingredient_preparation",
  7: "ingredient_health",
  8: "ingredient_environment",
  9: "quantity_name_plural",
  10: "quantity_name_singular",
  11: "quantity_ingredient_name",
  12: "quantity_unit_id",
  13: "quantity_unit",
  14: "quantity_default_weight",
  15: "quantity_default_weight_per_unit",
  16: "quantity_default_number_of_units",
  17: "quantity_step",
  18: "quantity_image_url",
};

/**
 * Column ranges defining data hierarchy levels.
 * 
 * @constant {number[][]} Array of [start, end) ranges
 */
// Level of depths (end excluded)
const categoriesRange = [0, 3];
const ingredientsRange = [3, 9];
const quantitiesRange = [9, 18];

/**
 * Converts a parsed line array into an object using COLUMNS mapping.
 * Only includes cells with non-empty values.
 * Trims trailing whitespace, line feeds, and carriage returns.
 * 
 * @param {string[]} line - Parsed line array
 * @returns {Object} Object with column names as keys
 */
const createObject = (line) => {
  const rep = {};
  line.forEach((value, colIndex) => {
    if (value !== "") {
      // remove trailing spaces, line feeds and carriage returns
      value = value.replace(/\s+$/g, "");
      rep[COLUMNS[colIndex]] = value;
    }
  });
  return rep;
};

/**
 * Main data structure holding parsed categories, ingredients, and quantities.
 * 
 * @type {Object}
 * @property {Object.<string, CategoryData>} categories - Categories indexed by category_id
 * @property {Object.<string, IngredientData>} ingredients - Ingredients indexed by ingredient_id
 * @property {Object.<string, QuantityData>} quantities - Quantities indexed by quantity_id
 */
const data = {
  categories: {},
  ingredients: {},
  quantities: {},
};

/**
 * Tracks the current parsing context (category and ingredient being processed).
 * Updated as we iterate through the TSV rows.
 * 
 * @type {Object}
 * @property {string} category_id - Current category ID
 * @property {string} ingredient_id - Current ingredient ID
 * @property {string} ingredient_name - Current ingredient name
 */
let currentState = {};

/**
 * Main parsing loop - processes each line of the dataset.
 * 
 * Logic:
 * 1. Skip empty lines
 * 2. Check which level of data this line contains (category/ingredient/quantity)
 * 3. Update the appropriate data structure and currentState
 * 4. Build relationships (categories → ingredients → quantities)
 */
lines.slice(TITLE_LINE + 1).forEach((line) => {
  const parsedLine = parseLine(line);

  if (parsedLine.filter((element) => element !== "").length === 0) {
    return;
  }
  const lineObject = createObject(parsedLine);

  const isNewCategory = parsedLine
    .slice(...categoriesRange)
    .some((cell) => cell !== "");
  const isNewIngredient = parsedLine
    .slice(...ingredientsRange)
    .some((cell) => cell !== "");
  const isNewQuantity = parsedLine
    .slice(...quantitiesRange)
    .some((cell) => cell !== "");

  // Process category row
  if (isNewCategory) {
    currentState = { category_id: lineObject.category_id };
    data.categories[lineObject.category_id] = {
      ...lineObject,
      ingredients: [],
    };
    return;
  }
  
  // Process ingredient row
  if (isNewIngredient) {
    currentState = {
      category_id: currentState.category_id,
      ingredient_id: lineObject.ingredient_id,
      ingredient_name: lineObject.ingredient_name,
    };
    data.categories[currentState.category_id].ingredients.push(
      lineObject.ingredient_id
    );
    data.ingredients[lineObject.ingredient_id] = {
      ...lineObject,
      ...currentState,
      quantities: [],
    };
    return;
  }
  
  // Process quantity row
  if (isNewQuantity) {

    /**
     * Generate unique quantity ID by concatenating ingredient_id and quantity_unit_id.
     * Format: "ingredient.unit" (e.g., "chicken.breast-unit")
     * If no unit ID, just use ingredient_id (e.g., "rice")
     */
    // Concatenate ingredient_id and quantity_unit_id to get the unique quantity_id
    // e.g. beef.ground-meat or beef.meat
    // If we don't have a quantity_unit_id, just use the ingredient_id
    const quantity_id =
      currentState.ingredient_id + (lineObject.quantity_unit_id ? "." + lineObject.quantity_unit_id : '');
    lineObject.quantity_id = quantity_id;

    data.ingredients[currentState.ingredient_id].quantities.push(quantity_id);

    /**
     * Apply default values and parse numbers:
     * - Default unit: "g" (grams)
     * - Default ingredient name: use parent ingredient name
     * - Parse numeric fields: weights, units, step
     */
    // Defaultize values
    // if we don't have a unit in the table, assume it is "g"
    lineObject.quantity_unit = lineObject.quantity_unit || "g";    

    // If quantity_ingredient_name is not specified, use ingredient_name
    lineObject.quantity_ingredient_name =
      lineObject.quantity_ingredient_name || currentState.ingredient_name;

    // Parse numbers when provided
    lineObject.quantity_default_weight = parseNumber(
      lineObject.quantity_default_weight
    );
    lineObject.quantity_default_weight_per_unit = parseNumber(
      lineObject.quantity_default_weight_per_unit
    );
    lineObject.quantity_default_number_of_units = parseNumber(
      lineObject.quantity_default_number_of_units
    );
    lineObject.quantity_step = parseNumber(lineObject.quantity_step) ?? 1;


    data.quantities[quantity_id] = {
      ...lineObject,
      ...currentState,
    };
    return;
  }
});

/**
 * Validation step: Check that all ingredients have at least one quantity.
 * Throws an error if any ingredient has zero quantities.
 * This ensures data integrity before writing the output file.
 */
// Check that we don't have ingredients without quantities
Object.values(data.categories).forEach((category) => {
  console.log("category: " + category.category_id);
  category.ingredients.forEach((ingredient_id) => {
    console.log("- ingredient: " + ingredient_id);
    ingredient = data.ingredients[ingredient_id];
    if (ingredient.quantities.length == 0) {
      throw new Error("no quantities defined for ingredient " + ingredient.ingredient_id);
    }
  });
});

/**
 * Write the parsed data to data/ingredients_config.json.
 * Pretty-printed with 2-space indentation for readability.
 * 
 * Output structure:
 * {
 *   categories: { [id]: { category_name, category_id, ingredients: [...] } },
 *   ingredients: { [id]: { ingredient_name, ingredient_id, quantities: [...], ... } },
 *   quantities: { [id]: { quantity_id, quantity_unit, quantity_default_weight, ... } }
 * }
 */
fs.writeFile(
  "./data/ingredients_config.json",
  JSON.stringify(data, null, 2),
  (err) => {
    if (err) {
      console.error(err);
    }
    console.log("file updated");
  }
);
